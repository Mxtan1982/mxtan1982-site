<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MM Lucky Number Generator</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      background: #000;
      color: #ffd700;
      padding: 20px;
    }
    h1 {
      color: #ffeb3b;
      font-size: 32px;
    }
    label {
      font-weight: bold;
    }
    .grid-container {
      display: flex;
      gap: 40px;
      margin-top: 20px;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(4, 60px);
      gap: 5px;
      margin-bottom: 10px;
    }
    .main-grid {
      grid-template-rows: repeat(6, 60px);
    }
    .sub-grid {
      grid-template-rows: repeat(3, 60px);
    }
    .cell {
      border: 2px solid #ffa000;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      background: #212121;
      color: #ffeb3b;
      font-size: 20px;
    }
    input {
      padding: 8px;
      font-size: 16px;
      background: #111;
      color: #fff700;
      border: 1px solid #ffa000;
      border-radius: 4px;
    }
    button {
      margin-top: 10px;
      padding: 10px 20px;
      background-color: #ffeb3b;
      color: #000;
      border: none;
      border-radius: 4px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.3s;
    }
    button:hover {
      background-color: #fff176;
    }
    .result {
      margin-top: 20px;
      white-space: pre-wrap;
      background: #111;
      padding: 15px;
      border: 1px solid #ffb300;
      min-height: 120px;
      font-family: monospace;
      color: #ffe082;
    }
    h3 {
      color: #ffca28;
    }
    .disclaimer {
      margin-top: 40px;
      padding: 15px;
      border: 1px solid #ffb300;
      background: #222;
      color: #ffd54f;
      font-size: 14px;
      line-height: 1.5;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <h1>ğŸ”® MM Lucky Number Generator </h1>
  <label>MAGNUM DRAW NO./å¼€å½©æœŸå·ï¼ˆå¦‚ 200/25ï¼‰ï¼š</label>
  <input type="text" id="draw" placeholder="ä¾‹å¦‚ï¼š200/25" />
  <br /><br />
  <label>LUCKY DIGIT NUMBER/å¹¸è¿æ•°å­—ï¼ˆ0-9ï¼‰ï¼š</label>
  <input type="number" id="lucky" min="0" max="9" />
  <br />
  <button onclick="generateAll()">ğŸ°çœ‹å¹¿å‘Š ç”Ÿæˆå¹¸è¿å·ç </button>

  <div class="grid-container">
    <div>
      <h3>ä¸»å›¾ï¼ˆ4Ã—6ï¼‰</h3>
      <div class="grid main-grid" id="mainGrid"></div>
    </div>
    <div>
      <h3>å‰¯å›¾ï¼ˆ4Ã—3ï¼‰</h3>
      <div class="grid sub-grid" id="subGrid"></div>
    </div>
  </div>

  <h3>ğŸ¯ é¢„æµ‹å·ç ï¼ˆå½“å¤©Lucky Numberï¼Œå«å¹¸è¿æ•°å­—ï¼‰</h3>
  <div class="result" id="result"></div>

  <div class="disclaimer">
    <strong>ä½¿ç”¨è¯´æ˜ï¼š</strong><br />
    æœ¬è½¯ä»¶ä¸ºè¾…åŠ©å·¥å…·ï¼Œæ—¨åœ¨å¸®åŠ©ç”¨æˆ·é¢„æµ‹å¹¸è¿æ•°å­—ã€‚<br />
    è¯·åœ¨è¾“å…¥æ¡†ä¸­å¡«å†™å½“å¤©MAGNUMæœŸå·ï¼ˆæ ¼å¼å¦‚ï¼š200/25ï¼‰ï¼Œ<br />
    ç„¶åé€‰æ‹©æ‚¨çš„å¹¸è¿å·ç ï¼ˆ0-9ï¼‰ã€‚<br />
    ç‚¹å‡»"ç”Ÿæˆé¢„æµ‹å·ç "æŒ‰é’®ï¼Œå³å¯è·å¾—å½“å¤©å¹¸è¿å·ç åˆ—è¡¨ã€‚<br />
    æœ¬è½¯ä»¶ä¸º MAGNUM é¢„æµ‹è¾…åŠ©å·¥å…·ï¼Œä»…ä¾›å¨±ä¹ç”¨é€”ï¼Œä¸æ¶‰åŠåšå½©æˆ–é‡‘é’±äº¤æ˜“ã€‚<br />
    This app is for entertainment purposes only and does not promote gambling.<br />
    ç¥æ‚¨å¥½è¿ï¼
  </div>

  <script>
    function generateMainGrid(digits, issueDigit) {
      const grid = [];
      grid[0] = [
        (digits[0] + digits[1]) % 10,
        (digits[1] + digits[2]) % 10,
        (digits[2] + digits[0]) % 10,
        (digits[0] + issueDigit) % 10,
      ];
      for (let r = 1; r < 6; r++) {
        grid[r] = grid[r - 1].map((v) => (v + 6) % 10);
      }
      return grid;
    }

    function generateSubGrid(digits) {
      let mainNum = digits[0] * 100 + digits[1] * 10 + digits[2];
      mainNum = mainNum - 1;
      if (mainNum < 0) mainNum = 999;
      const mainDigits = [
        Math.floor(mainNum / 100),
        Math.floor((mainNum % 100) / 10),
        mainNum % 10,
      ];
      const grid = Array.from({ length: 3 }, () => Array(4).fill(null));
      grid[0][0] = mainDigits[0];
      grid[1][1] = mainDigits[1];
      grid[2][2] = mainDigits[2];
      const positions = [
        [2, 2], [1, 2], [0, 2], [0, 1], [1, 0],
        [2, 0], [2, 1], [2, 3], [1, 3], [0, 3]
      ];
      let val = mainDigits[2];
      for (let i = 1; i < positions.length; i++) {
        val = (val + 1) % 10;
        const [r, c] = positions[i];
        grid[r][c] = val;
      }
      return grid;
    }

    function getShapes(grid) {
      const result = [];
      const h = grid.length;
      const w = grid[0].length;

      // å¢å¼ºçš„Lå‹è¯†åˆ«ï¼ˆ8ä¸ªæ–¹å‘ï¼‰
      const lShapes = [
        [[0,0],[1,0],[2,0],[2,1]],  // å·¦ä¸‹L
        [[0,1],[1,1],[2,1],[2,0]],  // å³ä¸‹L
        [[0,0],[0,1],[1,1],[2,1]],  // å·¦ä¸ŠL
        [[0,1],[0,0],[1,0],[2,0]],  // å³ä¸ŠL
        [[0,0],[0,1],[0,2],[1,0]],  // å·¦ä¸‹æ¨ªL
        [[0,0],[0,1],[0,2],[1,2]],  // å³ä¸‹æ¨ªL
        [[1,0],[1,1],[1,2],[0,0]],  // å·¦ä¸Šæ¨ªL
        [[1,0],[1,1],[1,2],[0,2]]   // å³ä¸Šæ¨ªL
      ];

      // å¢å¼ºçš„Zå‹è¯†åˆ«ï¼ˆ4ä¸ªæ–¹å‘ï¼‰
      const zShapes = [
        [[0,0],[0,1],[1,1],[1,2]], // æ°´å¹³Z
        [[1,0],[1,1],[0,1],[0,2]], // æ°´å¹³åZ
        [[0,0],[1,0],[1,1],[2,1]], // å‚ç›´Z
        [[0,1],[1,1],[1,0],[2,0]]  // å‚ç›´åZ
      ];

      // å¢å¼ºçš„Tå‹è¯†åˆ«ï¼ˆ4ä¸ªæ–¹å‘ï¼‰
      const tShapes = [
        [[0,1],[1,0],[1,1],[1,2]], // ä¸ŠT
        [[1,1],[0,0],[0,1],[0,2]], // ä¸‹T
        [[1,0],[0,1],[1,1],[2,1]], // å·¦T
        [[1,1],[0,0],[1,0],[2,0]]  // å³T
      ];

      // å…¶ä»–å½¢çŠ¶è¯†åˆ«
      const shapeOffsets = [
        [[0,0],[0,1],[1,0],[1,1]],  // æ–¹å½¢
        [[0,0],[1,0],[2,0],[3,0]],  // å‚ç›´ç›´çº¿
        [[0,0],[0,1],[0,2],[0,3]],  // æ°´å¹³ç›´çº¿
        [[0,0],[1,1],[2,2],[3,3]],  // å¯¹è§’çº¿
        [[0,3],[1,2],[2,1],[3,0]]   // åå¯¹è§’çº¿
      ];

      // æ£€æŸ¥æ‰€æœ‰Lå‹
      for (let r = 0; r < h; r++) {
        for (let c = 0; c < w; c++) {
          for (let shape of lShapes) {
            const pos = shape.map(([dr, dc]) => [r + dr, c + dc]);
            if (pos.every(([rr, cc]) => rr < h && cc < w)) {
              const num = pos.map(([rr, cc]) => grid[rr][cc]).join('');
              if (!num.includes('null')) {
                result.push(num);
              }
            }
          }
        }
      }

      // æ£€æŸ¥æ‰€æœ‰Zå‹
      for (let r = 0; r < h; r++) {
        for (let c = 0; c < w; c++) {
          for (let shape of zShapes) {
            const pos = shape.map(([dr, dc]) => [r + dr, c + dc]);
            if (pos.every(([rr, cc]) => rr < h && cc < w)) {
              const num = pos.map(([rr, cc]) => grid[rr][cc]).join('');
              if (!num.includes('null')) {
                result.push(num);
              }
            }
          }
        }
      }

      // æ£€æŸ¥æ‰€æœ‰Tå‹
      for (let r = 0; r < h; r++) {
        for (let c = 0; c < w; c++) {
          for (let shape of tShapes) {
            const pos = shape.map(([dr, dc]) => [r + dr, c + dc]);
            if (pos.every(([rr, cc]) => rr < h && cc < w)) {
              const num = pos.map(([rr, cc]) => grid[rr][cc]).join('');
              if (!num.includes('null')) {
                result.push(num);
              }
            }
          }
        }
      }

      // æ£€æŸ¥å…¶ä»–å½¢çŠ¶
      for (let r = 0; r < h; r++) {
        for (let c = 0; c < w; c++) {
          for (let shape of shapeOffsets) {
            const pos = shape.map(([dr, dc]) => [r + dr, c + dc]);
            if (pos.every(([rr, cc]) => rr < h && cc < w)) {
              const num = pos.map(([rr, cc]) => grid[rr][cc]).join('');
              if (!num.includes('null')) {
                result.push(num);
              }
            }
          }
        }
      }

      return result;
    }

    function renderGrid(grid, elementId) {
      const container = document.getElementById(elementId);
      container.innerHTML = '';
      for (let r = 0; r < grid.length; r++) {
        for (let c = 0; c < grid[0].length; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.innerText = grid[r][c] === null ? '' : grid[r][c];
          container.appendChild(cell);
        }
      }
    }

    function generateAll() {
      const drawInput = document.getElementById('draw').value.trim();
      const lucky = parseInt(document.getElementById('lucky').value);
      const match = drawInput.match(/^(\d{3})\/(\d{2})$/);
      if (!match) {
        alert('æ ¼å¼é”™è¯¯ï¼Œåº”ä¸ºä¾‹å¦‚ 200/25');
        return;
      }
      const mainNumberStr = match[1];
      const digits = mainNumberStr.split('').map(Number);
      const issueDigit = parseInt(match[2][1]);
      const mainGrid = generateMainGrid(digits, issueDigit);
      const subGrid = generateSubGrid(digits);
      renderGrid(mainGrid, 'mainGrid');
      renderGrid(subGrid, 'subGrid');
      
      let allNumbers = getShapes(mainGrid).concat(getShapes(subGrid));
      
      // å»é‡é€»è¾‘ï¼šå°†æ•°å­—æ’åºåæ¯”è¾ƒï¼Œé¿å…é¡ºåºä¸åŒä½†æ•°å­—ç›¸åŒçš„ç»„åˆ
      const uniqueNumbers = [];
      const seen = new Set();
      
      for (const num of allNumbers) {
        // å°†æ•°å­—æ‹†åˆ†æˆæ•°ç»„ï¼Œæ’åºåå†ç»„åˆæˆå­—ç¬¦ä¸²è¿›è¡Œæ¯”è¾ƒ
        const sorted = num.split('').sort().join('');
        if (!seen.has(sorted) && num.includes(lucky.toString())) {
          seen.add(sorted);
          uniqueNumbers.push(num);
        }
      }
      
      // é™åˆ¶æ˜¾ç¤ºæ•°é‡
      const displayNumbers = uniqueNumbers.slice(0, 100);
      const grouped = displayNumbers.reduce((acc, val, i) => {
        if (i % 5 === 0) acc.push([]);
        acc[acc.length - 1].push(val);
        return acc;
      }, []);
      
      const resultText = grouped.map((row) => row.join('    ')).join('\n');
      document.getElementById('result').innerText = resultText;
    }
  </script>
</body>
</html>
